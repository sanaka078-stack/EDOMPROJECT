import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { supabase } from "@/integrations/supabase/client";
import { toast } from "sonner";

export interface SupportTicket {
  id: string;
  ticket_number: string;
  customer_id?: string | null;
  customer_name: string;
  customer_email: string;
  customer_phone: string | null;
  subject: string;
  description: string | null;
  status: 'open' | 'in_progress' | 'waiting' | 'resolved' | 'closed';
  priority: 'low' | 'medium' | 'high' | 'urgent';
  category: string | null;
  assigned_to: string | null;
  tags?: string[];
  first_response_at?: string | null;
  response_time_seconds?: number | null;
  user_id?: string | null;
  created_at: string;
  updated_at: string;
}

export interface TicketReply {
  id: string;
  ticket_id: string;
  sender_type: string | null;
  sender_id?: string | null;
  user_id?: string | null;
  sender_name: string | null;
  message: string;
  content?: string;
  attachments: any;
  is_internal?: boolean;
  created_at: string;
}

export interface CreateTicketData {
  customer_name: string;
  customer_email: string;
  customer_phone?: string;
  subject: string;
  description?: string;
  priority?: 'low' | 'medium' | 'high' | 'urgent';
  category?: string;
}

export interface CreateReplyData {
  ticket_id: string;
  content: string;
  sender_name?: string;
}

export function useSupportTickets() {
  const queryClient = useQueryClient();

  // Fetch all tickets
  const { data: tickets = [], isLoading, error } = useQuery({
    queryKey: ["support-tickets"],
    queryFn: async () => {
      const { data, error } = await supabase
        .from("support_tickets")
        .select("*")
        .order("created_at", { ascending: false });

      if (error) throw error;
      return (data || []).map((item): SupportTicket => ({
        id: item.id,
        ticket_number: item.ticket_number,
        customer_id: (item as any).customer_id ?? null,
        customer_name: item.customer_name,
        customer_email: item.customer_email,
        customer_phone: item.customer_phone,
        subject: item.subject,
        description: item.description,
        status: item.status as SupportTicket['status'],
        priority: item.priority as SupportTicket['priority'],
        category: item.category,
        assigned_to: item.assigned_to,
        tags: (item as any).tags ?? [],
        first_response_at: item.first_response_at,
        response_time_seconds: item.response_time_seconds,
        user_id: item.user_id,
        created_at: item.created_at,
        updated_at: item.updated_at,
      }));
    },
  });

  // Create ticket
  const createTicket = useMutation({
    mutationFn: async (ticketData: CreateTicketData) => {
      const { data, error } = await supabase
        .from("support_tickets")
        .insert({
          customer_name: ticketData.customer_name,
          customer_email: ticketData.customer_email,
          customer_phone: ticketData.customer_phone || null,
          subject: ticketData.subject,
          description: ticketData.description || null,
          priority: ticketData.priority || 'medium',
          category: ticketData.category || null,
          ticket_number: '', // Will be auto-generated by trigger
        })
        .select()
        .single();

      if (error) throw error;
      return data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["support-tickets"] });
      toast.success("টিকেট সফলভাবে তৈরি হয়েছে");
    },
    onError: (error) => {
      console.error("Error creating ticket:", error);
      toast.error("টিকেট তৈরি করতে ব্যর্থ হয়েছে");
    },
  });

  // Update ticket status
  const updateTicketStatus = useMutation({
    mutationFn: async ({ id, status }: { id: string; status: SupportTicket['status'] }) => {
      const { error } = await supabase
        .from("support_tickets")
        .update({ status })
        .eq("id", id);

      if (error) throw error;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["support-tickets"] });
      toast.success("টিকেট স্ট্যাটাস আপডেট হয়েছে");
    },
    onError: (error) => {
      console.error("Error updating ticket status:", error);
      toast.error("স্ট্যাটাস আপডেট করতে ব্যর্থ হয়েছে");
    },
  });

  // Update ticket priority
  const updateTicketPriority = useMutation({
    mutationFn: async ({ id, priority }: { id: string; priority: SupportTicket['priority'] }) => {
      const { error } = await supabase
        .from("support_tickets")
        .update({ priority })
        .eq("id", id);

      if (error) throw error;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["support-tickets"] });
      toast.success("প্রায়োরিটি আপডেট হয়েছে");
    },
    onError: (error) => {
      console.error("Error updating priority:", error);
      toast.error("প্রায়োরিটি আপডেট করতে ব্যর্থ হয়েছে");
    },
  });

  // Assign ticket
  const assignTicket = useMutation({
    mutationFn: async ({ id, assigned_to }: { id: string; assigned_to: string | null }) => {
      const { error } = await supabase
        .from("support_tickets")
        .update({ assigned_to })
        .eq("id", id);

      if (error) throw error;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["support-tickets"] });
      toast.success("টিকেট অ্যাসাইন হয়েছে");
    },
    onError: (error) => {
      console.error("Error assigning ticket:", error);
      toast.error("অ্যাসাইন করতে ব্যর্থ হয়েছে");
    },
  });

  // Delete ticket
  const deleteTicket = useMutation({
    mutationFn: async (id: string) => {
      const { error } = await supabase
        .from("support_tickets")
        .delete()
        .eq("id", id);

      if (error) throw error;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["support-tickets"] });
      toast.success("টিকেট ডিলিট হয়েছে");
    },
    onError: (error) => {
      console.error("Error deleting ticket:", error);
      toast.error("ডিলিট করতে ব্যর্থ হয়েছে");
    },
  });

  // Bulk delete tickets
  const bulkDeleteTickets = useMutation({
    mutationFn: async (ids: string[]) => {
      const { error } = await supabase
        .from("support_tickets")
        .delete()
        .in("id", ids);

      if (error) throw error;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["support-tickets"] });
      toast.success("টিকেটগুলো ডিলিট হয়েছে");
    },
    onError: (error) => {
      console.error("Error bulk deleting tickets:", error);
      toast.error("ডিলিট করতে ব্যর্থ হয়েছে");
    },
  });

  // Bulk update ticket status
  const bulkUpdateStatus = useMutation({
    mutationFn: async ({ ids, status }: { ids: string[]; status: SupportTicket['status'] }) => {
      const { error } = await supabase
        .from("support_tickets")
        .update({ status })
        .in("id", ids);

      if (error) throw error;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["support-tickets"] });
      toast.success("স্ট্যাটাস আপডেট হয়েছে");
    },
    onError: (error) => {
      console.error("Error bulk updating status:", error);
      toast.error("আপডেট করতে ব্যর্থ হয়েছে");
    },
  });

  // Bulk assign tickets
  const bulkAssignTickets = useMutation({
    mutationFn: async ({ ids, assigned_to }: { ids: string[]; assigned_to: string | null }) => {
      const { error } = await supabase
        .from("support_tickets")
        .update({ assigned_to })
        .in("id", ids);

      if (error) throw error;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["support-tickets"] });
      toast.success("টিকেটগুলো অ্যাসাইন হয়েছে");
    },
    onError: (error) => {
      console.error("Error bulk assigning tickets:", error);
      toast.error("অ্যাসাইন করতে ব্যর্থ হয়েছে");
    },
  });

  // Stats
  const stats = {
    total: tickets.length,
    open: tickets.filter(t => t.status === 'open').length,
    inProgress: tickets.filter(t => t.status === 'in_progress').length,
    waiting: tickets.filter(t => t.status === 'waiting').length,
    resolved: tickets.filter(t => t.status === 'resolved').length,
    closed: tickets.filter(t => t.status === 'closed').length,
    pending: tickets.filter(t => t.status !== 'resolved' && t.status !== 'closed').length,
  };

  return {
    tickets,
    isLoading,
    error,
    stats,
    createTicket: createTicket.mutate,
    updateTicketStatus: updateTicketStatus.mutate,
    updateTicketPriority: updateTicketPriority.mutate,
    assignTicket: assignTicket.mutate,
    deleteTicket: deleteTicket.mutate,
    bulkDeleteTickets: bulkDeleteTickets.mutate,
    bulkUpdateStatus: bulkUpdateStatus.mutate,
    bulkAssignTickets: bulkAssignTickets.mutate,
    isCreating: createTicket.isPending,
    isBulkDeleting: bulkDeleteTickets.isPending,
    isBulkUpdating: bulkUpdateStatus.isPending || bulkAssignTickets.isPending,
  };
}

// Hook for ticket replies
export function useTicketReplies(ticketId: string | null) {
  const queryClient = useQueryClient();

  const { data: replies = [], isLoading } = useQuery({
    queryKey: ["ticket-replies", ticketId],
    queryFn: async () => {
      if (!ticketId) return [];
      
      const { data, error } = await supabase
        .from("ticket_replies")
        .select("*")
        .eq("ticket_id", ticketId)
        .order("created_at", { ascending: true });

      if (error) throw error;
      return (data || []).map((item): TicketReply => ({
        id: item.id,
        ticket_id: item.ticket_id,
        sender_type: item.sender_type,
        sender_id: (item as any).sender_id ?? null,
        user_id: item.user_id,
        sender_name: item.sender_name,
        message: item.message,
        content: item.message,
        attachments: item.attachments,
        is_internal: item.is_internal,
        created_at: item.created_at,
      }));
    },
    enabled: !!ticketId,
  });

  const createReply = useMutation({
    mutationFn: async (replyData: CreateReplyData) => {
      const { data: userData } = await supabase.auth.getUser();
      
      const { data, error } = await supabase
        .from("ticket_replies")
        .insert({
          ticket_id: replyData.ticket_id,
          message: replyData.content,
          sender_type: 'admin',
          user_id: userData.user?.id || null,
          sender_name: replyData.sender_name || 'Admin',
        })
        .select()
        .single();

      if (error) throw error;
      return data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["ticket-replies", ticketId] });
      toast.success("রিপ্লাই পাঠানো হয়েছে");
    },
    onError: (error) => {
      console.error("Error creating reply:", error);
      toast.error("রিপ্লাই পাঠাতে ব্যর্থ হয়েছে");
    },
  });

  return {
    replies,
    isLoading,
    createReply: createReply.mutate,
    isCreatingReply: createReply.isPending,
  };
}
